<!doctype html><html lang="en"><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Chess (local 2-player)</title>
<style>
body{margin:0;background:#0b2258;color:#fff;font-family:system-ui}
header{display:flex;gap:8px;justify-content:center;padding:10px}
.btn{background:#1c56ff;border:none;color:#fff;padding:8px 12px;border-radius:8px;font-weight:600}
#board{width:min(90vw,520px);aspect-ratio:1;margin:10px auto;border-radius:12px;overflow:hidden;box-shadow:0 12px 40px rgba(0,0,0,.35)}
.row{display:grid;grid-template-columns:repeat(8,1fr);height:12.5%}
.sq{display:grid;place-items:center;font-size:calc(min(90vw,520px)/10);user-select:none}
.d{background:#b58863}.l{background:#f0d9b5}
.sel{outline:3px solid #00e0ff}
.hint::after{content:"";width:35%;height:35%;border-radius:50%;background:#00e0ff99}
.bar{display:flex;justify-content:center;gap:12px}
</style>
<body>
<header>
<button class="btn" id="restart">Restart</button>
<button class="btn" id="flip">Flip</button>
<div>Turn: <b id="turn">White</b></div>
</header>
<div id="board"></div>
<div class="bar"><small>Drag/tap to move. No castling/en passant; basic checks only.</small></div>
<script>
/* light chess: pieces, legal moves (basic), check block, promotions to Queen */
const board = document.getElementById('board'), turnEl = document.getElementById('turn');
let flipped=false, sel=null, turn='w';
const EMPTY='.', START=[
'rnbqkbnr',
'pppppppp',
'........',
'........',
'........',
'........',
'PPPPPPPP',
'RNBQKBNR'
].join('');
let S = START.split('');
function idx(r,c){return r*8+c}
function pieceAt(r,c){return S[idx(r,c)]}
function colorOf(p){return p>='a'&&p<='z'?'b':p>='A'&&p<='Z'?'w':null}
function isEnemy(r,c){const p=pieceAt(r,c);return p!=='.'&&colorOf(p)!==turn}
function inB(r,c){return r>=0&&r<8&&c>=0&&c<8}
function clone(){return S.slice()}
function setAt(r,c,v){S[idx(r,c)]=v}
function kingPos(side){const k = side==='w'?'K':'k'; const i=S.join('').indexOf(k); return [Math.floor(i/8),i%8]}

function movesFrom(r,c){
const p=pieceAt(r,c); if(p=='.'||colorOf(p)!==turn) return [];
const isW=colorOf(p)==='w', P=p.toLowerCase();
const out=[];
const push=(rr,cc,cap=false)=>{ if(!inB(rr,cc))return;
const t=pieceAt(rr,cc); if(t==='.'|| (cap && colorOf(t)!==turn)) out.push([rr,cc]); }
const ray=(dr,dc)=>{ let rr=r+dr,cc=c+dc;
while(inB(rr,cc)){ if(pieceAt(rr,cc)==='.') out.push([rr,cc]);
else { if(colorOf(pieceAt(rr,cc))!==turn) out.push([rr,cc]); break;}
rr+=dr; cc+=dc; }
}
switch(P){
case 'p':{ const dir=isW?-1:1; // forward
if(inB(r+dir,c)&&pieceAt(r+dir,c)==='.') out.push([r+dir,c]);
const sr=isW?6:1; if(r===sr&&pieceAt(r+dir,c)==='.'&&pieceAt(r+2*dir,c)==='.') out.push([r+2*dir,c]);
// captures
[[dir,-1],[dir,1]].forEach(([dr,dc])=>{
const rr=r+dr,cc=c+dc; if(inB(rr,cc)&&pieceAt(rr,cc)!='.'&&colorOf(pieceAt(rr,cc))!==turn) out.push([rr,cc]);
});
break;
}
case 'n': [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(d=>{
const rr=r+d[0],cc=c+d[1]; if(inB(rr,cc) && colorOf(pieceAt(rr,cc))!==turn) out.push([rr,cc]);
}); break;
case 'b': ray(-1,-1); ray(-1,1); ray(1,-1); ray(1,1); break;
case 'r': ray(-1,0); ray(1,0); ray(0,-1); ray(0,1); break;
case 'q': [-1,0,1].forEach(dr=>[-1,0,1].forEach(dc=>{if(dr||dc)ray(dr,dc)})); break;
case 'k': for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(dr||dc) push(r+dr,c+dc,true) } break;
}
// filter self-check
return out.filter(([rr,cc])=>{
const bak=clone(); const p=pieceAt(r,c); const t=pieceAt(rr,cc);
setAt(rr,cc,p); setAt(r,c,'.');
// promotion
if(p==='P'&&rr===0) setAt(rr,cc,'Q'); if(p==='p'&&rr===7) setAt(rr,cc,'q');
const safe = !inCheck(turn);
S=bak; return safe;
});
}
function inCheck(side){
const saveTurn=turn; turn=side==='w'?'b':'w'; // look from enemy perspective
const [kr,kc]=kingPos(side); // can enemy capture king?
for(let r=0;r<8;r++)for(let c=0;c<8;c++)
if(colorOf(pieceAt(r,c))===turn && movesFrom(r,c).some(([rr,cc])=>rr===kr&&cc===kc)){ turn=saveTurn; return true;}
turn=saveTurn; return false;
}
function make(r,c,rr,cc){
const p=pieceAt(r,c); setAt(rr,cc,p); setAt(r,c,'.');
if(p==='P'&&rr===0) setAt(rr,cc,'Q'); if(p==='p'&&rr===7) setAt(rr,cc,'q');
turn = (turn==='w')?'b':'w'; turnEl.textContent = turn==='w'?'White':'Black';
render();
}
function sqEl(r,c,p){ const e=document.createElement('div');
e.className='sq '+(((r+c)&1)?'d':'l'); e.dataset.r=r; e.dataset.c=c;
e.textContent = pieceToGlyph(p); e.style.transform = flipped?'scaleY(-1)':'none'; return e;
}
function pieceToGlyph(p){
return {'K':'♔','Q':'♕','R':'♖','B':'♗','N':'♘','P':'♙',
'k':'♚','q':'♛','r':'♜','b':'♝','n':'♞','p':'♟︎','.' : ''}[p]||''
}
function render(){
board.innerHTML='';
const wrap = flipped?[...Array(8).keys()].reverse():[...Array(8).keys()];
wrap.forEach(r=>{
const row=document.createElement('div'); row.className='row';
(flipped?[...Array(8).keys()].reverse():[...Array(8).keys()]).forEach(c=>{
row.appendChild(sqEl(r,c,pieceAt(r,c)));
}); board.appendChild(row);
});
}
let hints=[];
function clearHints(){hints.forEach(el=>el.classList.remove('hint')); hints=[]}
board.addEventListener('click',e=>{
const s=e.target.closest('.sq'); if(!s)return; const r=+s.dataset.r,c=+s.dataset.c;
if(sel){ // try move
const [sr,sc]=sel; const ok = movesFrom(sr,sc).some(([rr,cc])=>rr===r&&cc===c);
clearHints(); document.querySelectorAll('.sel').forEach(el=>el.classList.remove('sel'));
if(ok) make(sr,sc,r,c); sel=null; return;
}
// select if own piece
if(pieceAt(r,c)!='.' && colorOf(pieceAt(r,c))===turn){
document.querySelectorAll('.sel').forEach(el=>el.classList.remove('sel'));
s.classList.add('sel'); sel=[r,c];
clearHints(); movesFrom(r,c).forEach(([rr,cc])=>{
const q=[...board.querySelectorAll('.sq')].find(el=>+el.dataset.r===rr&&+el.dataset.c===cc);
if(q){ q.classList.add('hint'); hints.push(q); }
});
}
});
document.getElementById('restart').onclick=()=>{S=START.split(''); turn='w'; sel=null; render(); turnEl.textContent='White'};
document.getElementById('flip').onclick=()=>{flipped=!flipped; render()};
render();
</script>
</body></html>
